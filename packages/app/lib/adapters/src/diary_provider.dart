import 'dart:async';

import 'package:clock/clock.dart';
import 'package:db_client/db_client.dart';
import 'package:diary/diary.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:scroll_calendar/scroll_calendar.dart';

import 'db_client_provider.dart';
import 'diary_image_provider.dart';

part 'diary_provider.g.dart';

/// A provider that creates a [DiaryCommand] instance.
///
/// {@macro diary.DiaryCommand}
@Riverpod(keepAlive: true)
DiaryCommand diaryCommand(Ref ref) {
  final dbClient = ref.watch(dbClientProvider);
  return DiaryCommand(dbClient: dbClient);
}

/// A provider that creates a [DiaryQuery] instance.
///
/// {@macro diary.DiaryQuery}
@Riverpod(keepAlive: true)
DiaryQuery diaryQuery(Ref ref) {
  final dbClient = ref.watch(dbClientProvider);
  return DiaryQuery(dbClient: dbClient);
}

/// Provides a stream of the total diary image count.
///
/// Emits the current count whenever images are added or removed.
@riverpod
Stream<int> diaryImageCount(Ref ref) {
  final query = ref.watch(diaryQueryProvider);
  return query.diaryImageCount();
}

/// Provides a list of diaries within the specified date range.
@riverpod
Future<List<Diary>> diaries(
  // Changed `from` to `fromDate`/`toDate` to avoid conflict with code generated by Riverpod Generator.
  Ref ref, {
  required DateTime fromDate,
  required DateTime toDate,
}) async {
  final query = ref.watch(diaryQueryProvider);
  return query.getDiaries(from: fromDate, to: toDate);
}

/// Type definition for a list of diaries with dates.
typedef DiariesWithDates = ({List<Diary> diaries, List<DateTime> dates});

/// Provides a list of diaries with dates within the specified date range.
@riverpod
class CachedDiaries extends _$CachedDiaries {
  final DateTime _now = clock.now();

  DiaryCommand get _diaryCommand => ref.read(diaryCommandProvider);

  DiaryImageCommand get _imageCommand => ref.read(diaryImageCommandProvider);

  @override
  Future<DiariesWithDates> build() async {
    final nextMonthDate = DateTime(_now.year, _now.month + 1);
    final dates = _now.datesInMonths(-1, 0)..add(nextMonthDate);
    final diaries = await ref.watch(
      diariesProvider(fromDate: dates.first, toDate: dates.last).future,
    );
    return (diaries: diaries, dates: dates);
  }

  /// Load more older diaries.
  Future<void> loadMoreOlder() async {
    if (state.isLoading || !state.hasValue) {
      // Do nothing if the state is loading or has no value.
      return;
    }
    final current = state.requireValue;
    final previousMonthDates = current.dates.first.previousMonthDates;
    final diaries = await ref.read(
      diariesProvider(
        fromDate: previousMonthDates.first,
        toDate: current.dates.last,
      ).future,
    );
    state = AsyncValue.data((
      diaries: [...diaries, ...current.diaries],
      dates: [...previousMonthDates, ...current.dates],
    ));
  }

  /// Add a new diary entry.
  Future<void> addDiary({
    required DateTime date,
    required String content,
  }) async {
    // Cannot use unawaited for optimistic update
    // because Diary ID is needed for state update.
    final entry = await _diaryCommand.addDiary(date: date, content: content);
    final diary = Diary(entry: entry);
    final current = state.requireValue;
    state = AsyncValue.data((
      diaries: [...current.diaries, diary],
      dates: current.dates,
    ));
  }

  /// Update an existing diary entry.
  Future<void> updateDiary({required int id, required String content}) async {
    unawaited(_diaryCommand.updateDiary(id: id, content: content));
    final current = state.requireValue;
    final updatedDiaries = current.diaries.map((diary) {
      final entry = diary.entry;
      if (entry.id == id) {
        return diary.copyWith(
          entry: entry.copyWith(content: content),
        );
      }
      return diary;
    }).toList();
    state = AsyncValue.data((diaries: updatedDiaries, dates: current.dates));
  }

  /// Add an image to a diary entry.
  ///
  /// If a diary doesn't exist for the specified date,
  /// creates an empty diary first.
  Future<void> addImage({
    required DateTime date,
    required String photoId,
  }) async {
    final current = state.requireValue;
    final existingDiary = current.diaries.where((d) {
      return d.entry.date == date;
    }).firstOrNull;

    if (existingDiary == null) {
      // Cannot use unawaited for optimistic update
      // because Diary ID is needed for state update.
      final entry = await _diaryCommand.addDiary(date: date, content: '');
      final newImage = await _imageCommand.addDiaryImage(
        diaryId: entry.id,
        photoId: photoId,
      );

      state = AsyncValue.data((
        diaries: [
          ...current.diaries,
          Diary(entry: entry, images: [newImage]),
        ],
        dates: current.dates,
      ));
      return;
    }

    final entry = existingDiary.entry;
    // Cannot use unawaited for optimistic update
    // because DiaryImage is needed for state update.
    final newImage = await _imageCommand.addDiaryImage(
      diaryId: entry.id,
      photoId: photoId,
    );

    final updatedDiaries = current.diaries.map((d) {
      if (d.entry.id == entry.id) {
        return d.copyWith(images: [...d.images, newImage]);
      }
      return d;
    }).toList();

    state = AsyncValue.data((diaries: updatedDiaries, dates: current.dates));
  }

  /// Delete an image from a diary entry.
  Future<void> deleteImage({required int imageId}) async {
    unawaited(_imageCommand.deleteDiaryImage(id: imageId));
    final current = state.requireValue;
    final updatedDiaries = current.diaries.map((diary) {
      return diary.copyWith(
        images: diary.images.where((img) => img.id != imageId).toList(),
      );
    }).toList();
    state = AsyncValue.data((diaries: updatedDiaries, dates: current.dates));
  }
}

/// Type definition for search result with pagination information.
typedef SearchResult = ({
  List<DiaryEntry> diaries,
  bool hasMore,
  String searchTerm,
});

/// Provides search functionality for diary entries.
@Riverpod(keepAlive: true)
class DiarySearch extends _$DiarySearch {
  static const int _pageSize = 20;

  @override
  SearchResult build() {
    return (diaries: [], hasMore: false, searchTerm: '');
  }

  /// Searches diary entries with the given search term.
  ///
  /// If [isLoadMore] is true, it appends results to existing ones.
  /// Otherwise, it replaces the current results.
  Future<void> search(String searchTerm, {bool isLoadMore = false}) async {
    if (searchTerm.trim().isEmpty) {
      state = (diaries: [], hasMore: false, searchTerm: '');
      return;
    }

    final diaryQuery = ref.read(diaryQueryProvider);
    final currentState = state;
    final offset = isLoadMore ? currentState.diaries.length : 0;

    final results = await diaryQuery.searchDiaries(
      searchTerm: searchTerm.trim(),
      limit: _pageSize,
      offset: offset,
    );

    final hasMore = results.length == _pageSize;
    final diaries = isLoadMore
        ? [...currentState.diaries, ...results]
        : results;

    state = (
      diaries: diaries,
      hasMore: hasMore,
      searchTerm: searchTerm.trim(),
    );
  }

  /// Loads more search results for the current search term.
  Future<void> loadMore() async {
    final currentState = state;
    if (currentState.hasMore && currentState.searchTerm.isNotEmpty) {
      await search(currentState.searchTerm, isLoadMore: true);
    }
  }

  /// Clears the search results.
  void clear() {
    state = (diaries: [], hasMore: false, searchTerm: '');
  }
}
